int minimax(int depth, int alpha, int beta, bool maximizingPlayer, int player, int x, int y) {
    if (depth == 0) {
        return evaluate(x, y) * player; // 将评估值乘以当前玩家，确保对手的评估值为负
    }

    if (maximizingPlayer) {
        int maxEval = INT32_MIN;
        for (int i = 0; i < 15; ++i) {
            for (int j = 0; j < 15; ++j) {
                if (board[i][j] == 0) {
                    board[i][j] = player;
                    int eval = minimax(depth - 1, alpha, beta, false, player, i, j);
                    maxEval = max(maxEval, eval);
                    alpha = max(alpha, eval);
                    board[i][j] = 0;
                    if (beta <= alpha) {
                        return maxEval; // Alpha-Beta剪枝
                    }
                }
            }
        }
        return maxEval;
    }
    else {
        int minEval = INT32_MAX;
        for (int i = 0; i < 15; ++i) {
            for (int j = 0; j < 15; ++j) {
                if (board[i][j] == 0) {
                    board[i][j] = -player; // 对手的分数设为负值
                    int eval = minimax(depth - 1, alpha, beta, true, player, i, j);
                    minEval = min(minEval, eval);
                    beta = min(beta, eval);
                    board[i][j] = 0;
                    if (beta <= alpha) {
                        return minEval; // Alpha-Beta剪枝
                    }
                }
            }
        }
        return minEval;
    }
}


// 执行最优的下一步
pair<int, int> nextMove(int board[15][15], int player) {
    int bestScore = INT32_MIN;
    int bestMoveX = -1;
    int bestMoveY = -1;
    for (int i = 0; i < 15; ++i) {
        for (int j = 0; j < 15; ++j) {
            if (board[i][j] == 0) {
                board[i][j] = player;
                int score = minimax(1, INT32_MIN, INT32_MAX, false, player,i,j);
                board[i][j] = 0;
                if (score > bestScore) {
                    bestScore = score;
                    bestMoveX = i;
                    bestMoveY = j;
                }
            }
        }
    }
    return pair<int, int>(bestMoveX, bestMoveY);
}
